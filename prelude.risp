(define (_map fn lst)
  (cond
   ((null? lst) nil)
   (t
    (cons (fn (car lst)) (_map fn (cdr lst))))))

(define (take n lst)
  (cond
   ((null? lst) nil)
   ((eq n 0) nil)
   (t
    (cons (car lst) (take (- n 1) (cdr lst))))))

(define (_filter pred lst)
  (cond
   ((null? lst) nil)
   ((pred (car lst))
    (cons (car lst) (_filter pred (cdr lst))))
   (t
    (_filter pred (cdr lst)))))

(define (filter pred lst)
  (flatten (map (lambda (e) (if (pred e) (list e) ())) lst)))

;; Fake things out so the defines are evaluated but not printed, since
;; they create infinite lists.

(and
  (define evens
     (cons 0 (map (lambda (a) (+ a 2)) evens)))
  'not-printed)

(and
  (define evens2
    (map (lambda (a) (+ a 2)) (cons 0 evens)))
  'not-printed)

;; This does not stream.

(define (foldl fn accum lst)
  (cond
   ((null? lst) accum)
   (t
    (foldl fn (fn accum (car lst)) (cdr lst)))))

;; This streams, e.g., to implement map and append.

(define (foldr fn tail lst)
  (cond
   ((null? lst) tail)
   (t
    (fn (car lst) (foldr fn tail (cdr lst))))))

;; Looking at the lambda, it looks like we're processing the list from
;; right to left to cons the result list from right to left.  And that
;; is what would happen with strict evaluation.  But with lazy
;; evaluation, the elements will be processed left to right and the
;; result list will be computed in order.  "tail" is actually the
;; lazily evaluated rest of the list which is yet to be computed.

(define (map fn lst)
  (foldr (lambda (e tail) (cons (fn e) tail)) nil lst))

;; This only works wight with lazy evaluation.

(define (if bool then else)
  (cond (bool then) (t else)))

(define (length lst)
  (foldr (lambda (_ tail) (+ 1 tail)) 0 lst))

(define (numbers first)
  (cons first (map (lambda (n) (+ n 1)) (numbers))))

(define (factorial n)
  (apply * (take n (numbers 1))))

(define (factorial n)
  (apply * (take n (cdr (numbers 0)))))

(define (reverse lst)
  (foldl (lambda (accum e) (cons e accum)) nil lst))

(define (flatten lst)
  (cond
   ((null? lst) nil)
   ((list? (car lst))
    (append (car lst) (flatten (cdr lst))))
   (t
    (cons (car lst) (flatten (cdr lst))))))

(define (flatten lst)
  (foldr (lambda (e tail)
           (cond
            ((list? e) (append e tail))
            (t (cons e tail))))
    nil lst))

;; This streams.

(define (append a b)
  (cond
   ((null? a) b)
   (t
    (cons (car a) (append (cdr a) b)))))

;; This streams, just like the definition above.

(define (append a b)
  (foldr (lambda (e tail) (cons e tail)) b a))

(define (nth n list)
  (cond
   ((null? list) nil)
   ((eq n 1)
    (car list))
   (t
    (nth (- n 1) (cdr list)))))

(define (zip a b)
  (cond
   ((null? a) nil)
   ((null? b) nil)
   (t
    (cons (list (car a) (car b)) (zip (cdr a) (cdr b))))))
