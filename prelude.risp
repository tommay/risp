;; Look, t and nil can be bound here instead of in the ruby code!

(define t 't)

(define nil 'nil)

;; The repl calls do-macros on the form before evaluating it.  Put
;; this first so it can be used for everything else.

;; There's a bit of a problem here.  Suppose the user enters:
;; (define-macro (p1 n) `(+ ,n 1))
;; Which the reader turns into
;; (define-macro (p1 n) (quasiquote (+ (unquote n) 1))
;; When we run do-macros on it before evaluation then 
;; the quasiquote will be handled on the spot and do-macros
;; returns (define-macro (p1 n) (+ n 1)) which is not what
;; we want.  Clearly we don't want do-macros to evaluate the
;; quasiuote.   Also if we want to be able to redefine p1 then
;  so-macros can't expand p1 in the argument list.
;; The solution for now is just don't expand macros within a
;; define-macro.  Note that this code treats define-macro as
;; quote anywhere in the form.

(define (do-macros form)
  (cond
   ((atom? form)
    form)
   ((eq (car form) 'quote)
    form)
   ((eq (car form) 'define-macro)
    form)
   ((and
      (symbol? (car form))
      (bound? (car form))
      (macro? (eval (car form))))
    (do-macros (eval form)))
   (t
    (map do-macros form))))

;; And the implementation for quasiquote and friends which the reader
;; puts in when "`", ",", and ",@" are used.
;; quasiquote is a macro so it can't just be used like a function below
;; because (quasiquote something) doesn't evaluate something it just
;; returns something, same as quote.  Using (apply quasiquote something)
;; works because apply evaluates its arguments.  However, it wants a
;; list of arguments to apply quasiquote to, so the thing to do is
;; (apply quasiquote (list something)) which will evaluate the something
;; and pass the result as the single argument to quasiquote.

;; A problem, and a workaround.  This simple macro should just return
;; its argument:
;; (define-macro (simple form) `,form)
;; But when this clause matches and runs:
;;   ((eq (car form) 'unquote)
;;    (eval (car (cdr form))))
;; form is bound to "(unqute form)" from the simple macro and
;; (car (cdr form)) is "form" so we fo (eval form) which returns
;; the binding of form from quasiquote not from simple.  The workaround
;; is to call "form" something more unusual in quasiquote so there
;; hopefully won't be collisions.  Or quasiquote could be done in ruby.

(define-macro (quasiquote -form-)
  (cond
   ((atom? -form-) -form-)
   ((eq (car -form-) 'unquote)
    (eval (car (cdr -form-))))
   ((atom? (car -form-))
    (cons (car -form-) (apply quasiquote (list (cdr -form-)))))
   ((eq (car (car -form-)) 'unquote-splicing)
    (append
      (eval (car (cdr (car -form-))))
      (apply quasiquote (list (cdr -form-)))))
   (t
    (cons
     (apply quasiquote (list (car -form-)))
     (apply quasiquote (list (cdr -form-)))))))

;; unquote and unquote-splicing are just markers for quasiquote.

(define (unquote form)
  (blow-chunks form))

(define (unquote-splicing form)
  (blow-chunking form))

(define (_map fn lst)
  (cond
   ((null? lst) nil)
   (t
    (cons (fn (car lst)) (_map fn (cdr lst))))))

(define (take n lst)
  (cond
   ((eq n 0) nil)
   ((null? lst) nil)
   (t
    (cons (car lst) (take (- n 1) (cdr lst))))))

(define (_filter pred lst)
  (cond
   ((null? lst) nil)
   ((pred (car lst))
    (cons (car lst) (_filter pred (cdr lst))))
   (t
    (_filter pred (cdr lst)))))

(define (filter pred lst)
  (flatten (map (lambda (e) (if (pred e) (list e) ())) lst)))

;; This does not stream.

(define (foldl fn accum lst)
  (cond
   ((null? lst) accum)
   (t
    (foldl fn (fn accum (car lst)) (cdr lst)))))

;; This streams, e.g., to implement map and append.

(define (foldr fn tail lst)
  (cond
   ((null? lst) tail)
   (t
    (fn (car lst) (foldr fn tail (cdr lst))))))

;; Looking at the lambda, it looks like we're processing the list from
;; right to left to cons the result list from right to left.  And that
;; is what would happen with strict evaluation.  But with lazy
;; evaluation, the elements will be processed left to right and the
;; result list will be computed in order.  "tail" is actually the
;; lazily evaluated rest of the list which is yet to be computed.

(define (map fn lst)
  (foldr (lambda (e tail) (cons (fn e) tail)) nil lst))

;; This only works wight with lazy evaluation.

(define (if bool then else)
  (cond (bool then) (t else)))

(define (length lst)
  (foldr (lambda (_ tail) (+ 1 tail)) 0 lst))

(define (numbers first)
  (letrec
   ((maker (cons first (map (lambda (n) (+ n 1)) maker))))
   maker))

;; Here are some simpler definitions for infinte number lists to make
;; it easier to find code problems.

(and
  lazy?
  (define numbers1
    (cons 1 (map (lambda (n) (+ n 1)) numbers1)))
  'not-printed)

(and
  lazy?
  (define numbers1a
    (cons 1 (_map (lambda (n) (+ n 1)) numbers1a)))
  'not-printed)

;; And even simpler:

(and
  lazy?
  (define ones
    (cons 1 ones))
  'not-printed)

(define (factorial n)
  (apply * (take n (numbers 1))))

(define (factorial2 n)
  (apply * (take n (cdr (numbers 0)))))

(define (triangle n)
  (apply + (take n (numbers 1))))

(define (reverse lst)
  (foldl (lambda (accum e) (cons e accum)) nil lst))

(define (flatten lst)
  (cond
   ((null? lst) nil)
   ((list? (car lst))
    (append (car lst) (flatten (cdr lst))))
   (t
    (cons (car lst) (flatten (cdr lst))))))

(define (flatten lst)
  (foldr (lambda (e tail)
           (cond
            ((list? e) (append e tail))
            (t (cons e tail))))
    nil lst))

;; This streams.

(define (append a b)
  (cond
   ((null? a) b)
   (t
    (cons (car a) (append (cdr a) b)))))

;; This streams, just like the definition above.

(define (append a b)
  (foldr (lambda (e tail) (cons e tail)) b a))

(define (nth n list)
  (cond
   ((null? list) nil)
   ((eq n 1)
    (car list))
   (t
    (nth (- n 1) (cdr list)))))

(define (zip a b)
  (cond
   ((null? a) nil)
   ((null? b) nil)
   (t
    (cons (list (car a) (car b)) (zip (cdr a) (cdr b))))))

;; Fake things out so the defines are evaluated but not printed, since
;; they create infinite lists.

(and
  lazy?
  (define evens
     (cons 0 (map (lambda (a) (+ a 2)) evens)))
  'not-printed)

(and
  lazy?
  (define evens2
    (map (lambda (a) (+ a 2)) (cons 0 evens2)))
  'not-printed)

;; factorial using the Y combinator:

(define yfact
  ((lambda (builder)
     (lambda (n) ((builder builder) n)))
   (lambda (recurse)
     (lambda (n)
       (cond
         ((eq n 0) 1)
         (t (* n ((recurse recurse) (- n 1)))))))))

;; triangle using the Y combinator.  This blows the stack even for
;; (ytriangle 100):

(define ytriangle
  ((lambda (builder)
     (lambda (n) ((builder builder) n)))
   (lambda (recurse)
     (lambda (n)
       (cond
         ((eq n 1) 1)
         (t (+ n ((recurse recurse) (- n 1)))))))))

;; Y combinator version of ones.  Note that yones is a lambda so it
;; needs (yones) to evaluate it.

(define yones
  ((lambda (builder)
     (lambda () ((builder builder))))
   (lambda (recurse)
     (lambda ()
       (cons 1 ((recurse recurse)))))))
