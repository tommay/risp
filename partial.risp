;; Macro (partial (func ...)) for partial function application.  E.g.,
;; (partial (+ 1)) returns a function that adds one to its (zero or
;; more) arguments.
;;
;; This is more efficient with functions that take a fixed number of
;; arguments.
;;
;; Partially applied functions can themselves be used with partial.

(load 'for)

;; Note that we want to capture the values of the partial arguments at
;; the time the lambda is created then use them in the lambda so the
;; lambda isn't recalculating them everhy time its invoked.  So the
;; lambda is created inside a let that evaluates the partial arguments
;; and binds then to gensyms.

(define-macro (partial func)
  (let* ((fn (eval (car func)))
	 (args (cdr func))
	 (arity (arity fn)))
    (cond
     ((null? arity)
      (let ((lambda-sym (gensym)))
	`(lambda (&rest ,lambda-sym)
	   (apply ,fn (append ',(map eval args) ,lambda-sym)))))
     (t
      (let* ((partial-syms
	      (map (lambda (_) (gensym)) args))
	     (zipped-args (zip partial-syms args))
	     (remaining (- arity (length args)))
	     (lambda-syms
	      (map (lambda (_) (gensym)) (take remaining (repeat nil)))))
	`(let ,zipped-args
	   (lambda ,lambda-syms (,fn ,@partial-syms ,@lambda-syms))))))))

;; (for (_ :in (take remaining (repeat nil))) (gensym))

(define (/= a b) (not (eq a b)))

(define (ne n) (partial (/= (+ n 1))))
;=> (let ((#1 n)) (lambda (#2) (/= #1 #2)))
